<map id="o2::header::BaseHeader" name="o2::header::BaseHeader">
<area shape="rect" id="node2" href="$d7/df0/structo2_1_1framework_1_1DataProcessingHeader.html" title="{o2::framework::DataProcessing\lHeader\n|+ startTime\l+ duration\l+ sHeaderType\l+ sVersion\l|+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ Get()\l}" alt="" coords="5,491,211,685"/>
<area shape="rect" id="node3" href="$db/d87/structo2_1_1header_1_1DataHeader.html" title="the main header struct " alt="" coords="235,425,428,751"/>
<area shape="rect" id="node4" href="$d4/dfa/structo2_1_1header_1_1HeartbeatFrameEnvelope.html" title="{o2::header::HeartbeatFrame\lEnvelope\n|+ header\l+ trailer\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ HeartbeatFrameEnvelope()\l+ HeartbeatFrameEnvelope()\l}" alt="" coords="453,505,643,671"/>
<area shape="rect" id="node5" href="$d2/dda/structo2_1_1header_1_1NameHeader.html" title="an example data header containing a name of an object as a null terminated char arr. this is a template! at instantiation the template parameter determines the size of the held string array. a caveat with decoding is (if length of string is not known) you have to use header::get&lt;NameHeader&lt;0&gt;&gt;(buffer) to get it out of a buffer. May improve in the future if enough people complain. If the compiler decides to pad the end of struct, the length of padding is stored in the last byte " alt="" coords="668,498,871,678"/>
</map>
